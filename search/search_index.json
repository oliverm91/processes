{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#processes-robust-routines-management","title":"\ud83d\ude80 Processes: Robust Routines Management","text":"<p>Processes is a lightweight, high-performance Python library designed to execute complex task graphs. It manages dependencies, handles parallel execution, and ensures system resilience without any external libraries.</p> <p>File logging and email notification is supported.</p>"},{"location":"#table-of-contents","title":"\ud83d\udcd1 Table of Contents","text":"<ul> <li>\u2728 Features</li> <li>\u2699\ufe0f Core Concepts</li> <li>\ud83d\udee0\ufe0f Use Cases</li> <li>\ud83d\udcbb Quick Start</li> <li>\ud83d\udee1\ufe0f Fault Tolerance &amp; Logs</li> <li>\ud83d\udce6 Installation</li> </ul>"},{"location":"#features","title":"\u2728 Features","text":"<ul> <li>\ud83d\udc0d Pure Python: Zero external dependencies. Built entirely on the Python Standard Library.</li> <li>\u26a1 Parallel Execution: Built-in support for parallelization to maximize throughput.</li> <li>\ud83d\udd17 Dependency Resolution: Automatically sorts and executes tasks based on their requirements, regardless of input order.</li> <li>\ud83d\udcdd Shared Logging: Multiple tasks can write to the same logfile or maintain separate ones seamlessly.</li> <li>\ud83d\udce7 Email Notifications: Integrated SMTP support (including HTML) to alert you the moment an exception occurs.</li> </ul>"},{"location":"#core-concepts","title":"\u2699\ufe0f Core Concepts","text":"<p>The library operates on two main primitives:</p> <ol> <li>Task: The atomic unit of work. It encapsulates a function, its parameters, its specific logfile, and its relationship with other tasks.</li> <li>Process: The orchestrator. It builds the execution graph, validates dependencies, and manages the lifecycle of the entire workflow.</li> </ol>"},{"location":"#use-cases","title":"\ud83d\udee0\ufe0f Use Cases","text":"<ul> <li> <p>ETL Pipelines: Fetch data from an API, transform it, and load it into a database as separate, dependent tasks.</p> </li> <li> <p>System Maintenance: Run parallel cleanup scripts, check server health, and receive email alerts if a specific check fails.</p> </li> <li> <p>Automated Reporting: Generate multiple data parts in parallel, aggregate them into a final report, and distribute via SMTP.</p> </li> </ul>"},{"location":"#quick-start","title":"\ud83d\udcbb Quick Start","text":"<p>Define your tasks and their dependencies. Processes will handle the execution order and data injection between tasks.</p> <pre><code>from datetime import date\n\nfrom processes import Process, Task, TaskDependency, HTMLSMTPHandler\n\n# 1. Setup Email Alerts (Optional)\nsmtp_handler = HTMLSMTPHandler(\n    ('smtp_server', 587), 'sender@example.com', ['admin@example.com', 'user@example.com'], \n    use_tls=True, credentials=('user', 'pass')\n)\n\n# 2. If necessary, create wrappers for your Tasks.\ndef get_previous_working_day():\n    return date(2025, 12, 30)\ndef indep_task():\n    return \"foo\"\ndef search_and_sum_csv(t: date):\n    return 10\ndef sum_data_from_csv_and_x(x, a=1, b=2):\n    return x + a + b\n\n# 3. Create the Task Graph (order is irrelevant, that is handled by Process)\ntasks = [\n    Task(\"t-1\", \"etl.log\", get_previous_working_day),\n    Task(\"intependent\", \"indep.log\", indep_task, html_mail_handler=smtp_handler),  # This task will send email on failure\n    Task(\"sum_csv\", \"etl.log\", search_and_sum_csv,\n            dependencies= [\n                TaskDependency(\"t-1\",\n                use_result_as_additional_args=True)  # Adds result of t-1 task to search_and_sum_csv function as aditional args\n            ]\n        ),\n    Task(\"sum_x_and_csv\", \"etl.log\", sum_data_from_csv_and_x,\n            args = (10,), kwargs = {\"b\": 100},\n            dependencies=[\n                TaskDependency(\"sum_csv\",\n            use_result_as_additional_kwargs=True,\n            additional_kwarg_name=\"a\")\n        ]\n    )\n]\n\n# 4. Run the Process\nwith Process(tasks) as process: # Context Manager ensures correct disposal of loggers\n    process_result = process.run() # To enable parallelization use .run(parallel=True)\n\n</code></pre>"},{"location":"#fault-tolerance-logs","title":"\ud83d\udee1\ufe0f Fault Tolerance &amp; Logs","text":""},{"location":"#resilience-by-design","title":"Resilience by Design","text":"<p>If a <code>Task</code> raises an exception, the <code>Process</code> does not stop. It intelligently skips any tasks that depend on the failed one but continues to execute all other independent branches of your workflow.</p>"},{"location":"#advanced-logging","title":"Advanced Logging","text":"<p>All tasks record their execution flow to their assigned logfiles. You can share a single logfile across the whole process or isolate specific tasks for easier debugging.</p>"},{"location":"#installation","title":"\ud83d\udce6 Installation","text":"<p>Registered in PyPI: https://pypi.org/project/processes/</p> <pre><code>pip install processes\n</code></pre> <p>Also, since it's a pure Python library, you can install it directly from the repository:</p> <pre><code>pip install git+https://github.com/oliverm91/processes.git\n</code></pre>"},{"location":"reference/","title":"API Reference","text":"<p>This page is automatically generated from the source code docstrings.</p> <p>Manages and executes a collection of interdependent tasks.</p> <p>A Process orchestrates the execution of multiple tasks, handling dependency resolution, task ordering. Task execution can be performed in parallel or sequentially. It provides logging management and error propagation for dependent tasks. If a task fails, all tasks depending on it are marked as failed without execution, but non-dependent tasks continue to run.</p> <p>Container for the results of a process execution.</p> <p>Holds the outcomes of all tasks executed in a process, separating successful and failed tasks with their respective results.</p> <p>A Task represents a unit of work to be executed within a Process.</p> <p>A Task encapsulates a callable function with its arguments, dependencies on other tasks, and logging configuration. Tasks can be executed, by the Process class, sequentially or in parallel, with automatic dependency resolution and result passing between dependent tasks.</p> <p>Represents a dependency relationship between tasks.</p> <p>Defines how a task depends on another task, including how the result of the dependency should be passed to the dependent task (as additional positional arguments, keyword arguments, or both).</p> <p>               Bases: <code>SMTPHandler</code></p> <p>A logging handler that sends log records via SMTP as HTML formatted emails.</p> <p>Extends the standard SMTPHandler to support HTML-formatted email messages, enabling richer formatting and styling in error notifications.</p>"},{"location":"reference/#processes.process.Process--attributes","title":"Attributes","text":"<p>tasks : list[Task]     List of tasks to be executed, automatically sorted by dependencies. runner : ProcessRunner     The runner responsible for executing the tasks.</p>"},{"location":"reference/#processes.process.Process--raises","title":"Raises","text":"<p>TypeError     If tasks is not a list or contains non-Task elements. ValueError     If duplicate task names are found. DependencyNotFoundError     If a task depends on a non-existent task. CircularDependencyError     If circular dependencies are detected among tasks.</p> Source code in <code>src/processes/process.py</code> <pre><code>class Process:\n    \"\"\"\n    Manages and executes a collection of interdependent tasks.\n\n    A Process orchestrates the execution of multiple tasks, handling dependency\n    resolution, task ordering. Task execution can be performed in parallel or sequentially. It\n    provides logging management and error propagation for dependent tasks. If a task fails,\n    all tasks depending on it are marked as failed without execution, but non-dependent tasks\n    continue to run.\n\n    Attributes\n    ----------\n    tasks : list[Task]\n        List of tasks to be executed, automatically sorted by dependencies.\n    runner : ProcessRunner\n        The runner responsible for executing the tasks.\n\n    Raises\n    ------\n    TypeError\n        If tasks is not a list or contains non-Task elements.\n    ValueError\n        If duplicate task names are found.\n    DependencyNotFoundError\n        If a task depends on a non-existent task.\n    CircularDependencyError\n        If circular dependencies are detected among tasks.\n    \"\"\"\n\n    def __init__(self, tasks: list[Task]):\n        self.tasks = tasks\n\n        try:\n            self._check_input_types()\n            self._check_duplicate_names()\n            self._check_dependencies_exist()\n            self._topological_sort()\n        except Exception as e:\n            self.close_loggers()\n            raise e\n        self.runner = ProcessRunner(self)\n\n    def __enter__(self) -&gt; Self:\n        \"\"\"Called when entering the 'with' block.\"\"\"\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type[BaseException] | None,\n        exc_value: BaseException | None,\n        traceback: TracebackType | None,\n    ) -&gt; Literal[False]:\n        \"\"\"Called when exiting the 'with' block, even if an error occurred.\"\"\"\n        self.close_loggers()\n        return False\n\n    def _check_input_types(self) -&gt; None:\n        \"\"\"Validate that tasks is a list containing only Task objects.\n\n        Raises\n        ------\n        TypeError\n            If tasks is not a list or contains non-Task elements.\n        \"\"\"\n        if not isinstance(self.tasks, list):\n            raise TypeError(f\"tasks must be list. Got {type(self.tasks)}\")\n        for task in self.tasks:\n            if not isinstance(task, Task):\n                raise TypeError(f\"task must be Task. Got {type(task)}\")\n\n    def _check_duplicate_names(self) -&gt; None:\n        \"\"\"Verify that all task names are unique.\n\n        Raises\n        ------\n        ValueError\n            If duplicate task names are found.\n        \"\"\"\n        names = set()\n        for task in self.tasks:\n            if task.name in names:\n                raise ValueError(f\"Duplicate task name: {task.name}\")\n            names.add(task.name)\n\n    def _check_dependencies_exist(self) -&gt; None:\n        \"\"\"Verify that all task dependencies refer to existing tasks.\n\n        Raises\n        ------\n        DependencyNotFoundError\n            If a task depends on a non-existent task.\n        \"\"\"\n        names = {t.name for t in self.tasks}\n        for task in self.tasks:\n            for dep in task.get_dependencies_names():\n                if dep not in names:\n                    raise DependencyNotFoundError(\n                        f\"Task {task.name} depends on missing task: {dep}\"\n                    )\n\n    def _topological_sort(self) -&gt; None:\n        \"\"\"Sort tasks based on dependencies using Kahn's Algorithm in O(V+E) time.\n\n        Reorders the task list so that dependencies are always executed before\n        tasks that depend on them.\n\n        Raises\n        ------\n        CircularDependencyError\n            If circular dependencies are detected among tasks.\n        \"\"\"\n        in_degree = {t.name: 0 for t in self.tasks}\n        graph: dict[str, list[str]] = {t.name: [] for t in self.tasks}\n        task_map = {t.name: t for t in self.tasks}\n\n        for task in self.tasks:\n            for dep in task.dependencies:\n                graph[dep.task_name].append(task.name)\n                in_degree[task.name] += 1\n\n        queue = [name for name, deg in in_degree.items() if deg == 0]\n        sorted_tasks = []\n\n        while queue:\n            u = queue.pop(0)\n            sorted_tasks.append(task_map[u])\n            for v in graph[u]:\n                in_degree[v] -= 1\n                if in_degree[v] == 0:\n                    queue.append(v)\n\n        if len(sorted_tasks) != len(self.tasks):\n            raise CircularDependencyError(\"Circular dependency detected.\")\n        self.tasks = sorted_tasks\n\n    def get_task(self, task_name: str) -&gt; Task:\n        \"\"\"Retrieve a task by name.\n\n        Parameters\n        ----------\n        task_name : str\n            The name of the task to retrieve.\n\n        Returns\n        -------\n        Task\n            The task with the specified name.\n\n        Raises\n        ------\n        TaskNotFoundError\n            If no task with the given name exists.\n        \"\"\"\n        for task in self.tasks:\n            if task.name == task_name:\n                return task\n        raise TaskNotFoundError(f\"Task not found: {task_name}\")\n\n    def run(self, parallel: bool | None = None, max_workers: int = 4) -&gt; ProcessResult:\n        \"\"\"Execute all tasks in the process.\n\n        Runs tasks sequentially or in parallel while respecting dependencies.\n        Dependencies are always resolved before dependent tasks are executed.\n\n        Parameters\n        ----------\n        parallel : bool, optional\n            Whether to run tasks in parallel while respecting dependencies.\n            If None, automatically set to True for processes with 10 or more tasks,\n            False otherwise. Defaults to None.\n        max_workers : int, optional\n            Maximum number of worker threads for parallel execution. Defaults to 4.\n            Only used when parallel=True. If set to 1, falls back to sequential execution.\n\n        Returns\n        -------\n        ProcessResult\n            Contains passed_tasks_results (dict mapping task names to TaskResult)\n            and failed_tasks (set of task names that failed).\n        \"\"\"\n        if parallel is None:\n            parallel = len(self.tasks) &gt;= 10\n\n        max_workers = max(1, max_workers)\n        if parallel:\n            if max_workers == 1:\n                parallel = False  # Fallback to sequential if only one worker\n        process_result = self.runner.run(parallel, max_workers)\n        return process_result\n\n    def get_dependant_tasks(self, task_name: str) -&gt; list[Task]:\n        \"\"\"Retrieve all tasks that directly or indirectly depend on a given task.\n\n        Parameters\n        ----------\n        task_name : str\n            The name of the task to find dependants for.\n\n        Returns\n        -------\n        list[Task]\n            List of all tasks that depend on the specified task, including\n            transitive dependencies (tasks that depend on tasks that depend\n            on the specified task).\n        \"\"\"\n        found = []\n\n        def find(name: str) -&gt; None:\n            for t in self.tasks:\n                if name in t.get_dependencies_names() and t not in found:\n                    found.append(t)\n                    find(t.name)\n\n        find(task_name)\n        return found\n\n    def close_loggers(self) -&gt; None:\n        \"\"\"Close and clean up all logger handlers for all tasks.\n\n        Should be called when the process is done to ensure proper resource cleanup.\n        \"\"\"\n        for task in self.tasks:\n            for handler in task.logger.handlers:\n                handler.close()\n                task.logger.removeHandler(handler)\n</code></pre>"},{"location":"reference/#processes.process.Process.__enter__","title":"<code>__enter__()</code>","text":"<p>Called when entering the 'with' block.</p> Source code in <code>src/processes/process.py</code> <pre><code>def __enter__(self) -&gt; Self:\n    \"\"\"Called when entering the 'with' block.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/#processes.process.Process.__exit__","title":"<code>__exit__(exc_type, exc_value, traceback)</code>","text":"<p>Called when exiting the 'with' block, even if an error occurred.</p> Source code in <code>src/processes/process.py</code> <pre><code>def __exit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_value: BaseException | None,\n    traceback: TracebackType | None,\n) -&gt; Literal[False]:\n    \"\"\"Called when exiting the 'with' block, even if an error occurred.\"\"\"\n    self.close_loggers()\n    return False\n</code></pre>"},{"location":"reference/#processes.process.Process.close_loggers","title":"<code>close_loggers()</code>","text":"<p>Close and clean up all logger handlers for all tasks.</p> <p>Should be called when the process is done to ensure proper resource cleanup.</p> Source code in <code>src/processes/process.py</code> <pre><code>def close_loggers(self) -&gt; None:\n    \"\"\"Close and clean up all logger handlers for all tasks.\n\n    Should be called when the process is done to ensure proper resource cleanup.\n    \"\"\"\n    for task in self.tasks:\n        for handler in task.logger.handlers:\n            handler.close()\n            task.logger.removeHandler(handler)\n</code></pre>"},{"location":"reference/#processes.process.Process.get_dependant_tasks","title":"<code>get_dependant_tasks(task_name)</code>","text":"<p>Retrieve all tasks that directly or indirectly depend on a given task.</p>"},{"location":"reference/#processes.process.Process.get_dependant_tasks--parameters","title":"Parameters","text":"<p>task_name : str     The name of the task to find dependants for.</p>"},{"location":"reference/#processes.process.Process.get_dependant_tasks--returns","title":"Returns","text":"<p>list[Task]     List of all tasks that depend on the specified task, including     transitive dependencies (tasks that depend on tasks that depend     on the specified task).</p> Source code in <code>src/processes/process.py</code> <pre><code>def get_dependant_tasks(self, task_name: str) -&gt; list[Task]:\n    \"\"\"Retrieve all tasks that directly or indirectly depend on a given task.\n\n    Parameters\n    ----------\n    task_name : str\n        The name of the task to find dependants for.\n\n    Returns\n    -------\n    list[Task]\n        List of all tasks that depend on the specified task, including\n        transitive dependencies (tasks that depend on tasks that depend\n        on the specified task).\n    \"\"\"\n    found = []\n\n    def find(name: str) -&gt; None:\n        for t in self.tasks:\n            if name in t.get_dependencies_names() and t not in found:\n                found.append(t)\n                find(t.name)\n\n    find(task_name)\n    return found\n</code></pre>"},{"location":"reference/#processes.process.Process.get_task","title":"<code>get_task(task_name)</code>","text":"<p>Retrieve a task by name.</p>"},{"location":"reference/#processes.process.Process.get_task--parameters","title":"Parameters","text":"<p>task_name : str     The name of the task to retrieve.</p>"},{"location":"reference/#processes.process.Process.get_task--returns","title":"Returns","text":"<p>Task     The task with the specified name.</p>"},{"location":"reference/#processes.process.Process.get_task--raises","title":"Raises","text":"<p>TaskNotFoundError     If no task with the given name exists.</p> Source code in <code>src/processes/process.py</code> <pre><code>def get_task(self, task_name: str) -&gt; Task:\n    \"\"\"Retrieve a task by name.\n\n    Parameters\n    ----------\n    task_name : str\n        The name of the task to retrieve.\n\n    Returns\n    -------\n    Task\n        The task with the specified name.\n\n    Raises\n    ------\n    TaskNotFoundError\n        If no task with the given name exists.\n    \"\"\"\n    for task in self.tasks:\n        if task.name == task_name:\n            return task\n    raise TaskNotFoundError(f\"Task not found: {task_name}\")\n</code></pre>"},{"location":"reference/#processes.process.Process.run","title":"<code>run(parallel=None, max_workers=4)</code>","text":"<p>Execute all tasks in the process.</p> <p>Runs tasks sequentially or in parallel while respecting dependencies. Dependencies are always resolved before dependent tasks are executed.</p>"},{"location":"reference/#processes.process.Process.run--parameters","title":"Parameters","text":"<p>parallel : bool, optional     Whether to run tasks in parallel while respecting dependencies.     If None, automatically set to True for processes with 10 or more tasks,     False otherwise. Defaults to None. max_workers : int, optional     Maximum number of worker threads for parallel execution. Defaults to 4.     Only used when parallel=True. If set to 1, falls back to sequential execution.</p>"},{"location":"reference/#processes.process.Process.run--returns","title":"Returns","text":"<p>ProcessResult     Contains passed_tasks_results (dict mapping task names to TaskResult)     and failed_tasks (set of task names that failed).</p> Source code in <code>src/processes/process.py</code> <pre><code>def run(self, parallel: bool | None = None, max_workers: int = 4) -&gt; ProcessResult:\n    \"\"\"Execute all tasks in the process.\n\n    Runs tasks sequentially or in parallel while respecting dependencies.\n    Dependencies are always resolved before dependent tasks are executed.\n\n    Parameters\n    ----------\n    parallel : bool, optional\n        Whether to run tasks in parallel while respecting dependencies.\n        If None, automatically set to True for processes with 10 or more tasks,\n        False otherwise. Defaults to None.\n    max_workers : int, optional\n        Maximum number of worker threads for parallel execution. Defaults to 4.\n        Only used when parallel=True. If set to 1, falls back to sequential execution.\n\n    Returns\n    -------\n    ProcessResult\n        Contains passed_tasks_results (dict mapping task names to TaskResult)\n        and failed_tasks (set of task names that failed).\n    \"\"\"\n    if parallel is None:\n        parallel = len(self.tasks) &gt;= 10\n\n    max_workers = max(1, max_workers)\n    if parallel:\n        if max_workers == 1:\n            parallel = False  # Fallback to sequential if only one worker\n    process_result = self.runner.run(parallel, max_workers)\n    return process_result\n</code></pre>"},{"location":"reference/#processes.process.ProcessResult--attributes","title":"Attributes","text":"<p>passed_tasks_results : dict[str, TaskResult]     Mapping of task names to TaskResult objects for all tasks that executed successfully. failed_tasks : set[str]     Set of task names for all tasks that failed during execution.</p> Source code in <code>src/processes/process.py</code> <pre><code>class ProcessResult:\n    \"\"\"\n    Container for the results of a process execution.\n\n    Holds the outcomes of all tasks executed in a process, separating successful\n    and failed tasks with their respective results.\n\n    Attributes\n    ----------\n    passed_tasks_results : dict[str, TaskResult]\n        Mapping of task names to TaskResult objects for all tasks that executed successfully.\n    failed_tasks : set[str]\n        Set of task names for all tasks that failed during execution.\n    \"\"\"\n\n    def __init__(self, passed_tasks_results: dict[str, TaskResult], failed_tasks: set[str]):\n        self.passed_tasks_results = passed_tasks_results\n        self.failed_tasks = failed_tasks\n</code></pre>"},{"location":"reference/#processes.task.Task--attributes","title":"Attributes","text":"<p>name : str     Unique name for the task (cannot contain spaces). log_path : str     File path where task logs will be written. func : Callable     The function to execute when the task runs. args : tuple     Positional arguments to pass to the function. Defaults to empty tuple. kwargs : dict     Keyword arguments to pass to the function. Defaults to empty dict. dependencies : list[TaskDependency]     List of tasks this task depends on. Defaults to empty list. html_mail_handler : HTMLSMTPHandler, optional     Handler for sending error logs via email in HTML format. Defaults to None. logger : logging.Logger     Logger instance for this task, automatically configured.</p> Source code in <code>src/processes/task.py</code> <pre><code>class Task:\n    \"\"\"\n    A Task represents a unit of work to be executed within a Process.\n\n    A Task encapsulates a callable function with its arguments, dependencies on other tasks,\n    and logging configuration. Tasks can be executed, by the Process class, sequentially\n    or in parallel, with automatic dependency resolution and result passing between dependent tasks.\n\n    Attributes\n    ----------\n    name : str\n        Unique name for the task (cannot contain spaces).\n    log_path : str\n        File path where task logs will be written.\n    func : Callable\n        The function to execute when the task runs.\n    args : tuple\n        Positional arguments to pass to the function. Defaults to empty tuple.\n    kwargs : dict\n        Keyword arguments to pass to the function. Defaults to empty dict.\n    dependencies : list[TaskDependency]\n        List of tasks this task depends on. Defaults to empty list.\n    html_mail_handler : HTMLSMTPHandler, optional\n        Handler for sending error logs via email in HTML format. Defaults to None.\n    logger : logging.Logger\n        Logger instance for this task, automatically configured.\n    \"\"\"\n\n    kwargs: dict[str, Any]\n    dependencies: list[TaskDependency]\n\n    def __init__(\n        self,\n        name: str,\n        log_path: str,\n        func: Callable[..., Any],\n        args: tuple[Any, ...] = (),\n        kwargs: dict[str, Any] | None = None,\n        dependencies: list[TaskDependency] | None = None,\n        html_mail_handler: HTMLSMTPHandler | None = None,\n    ):\n        self.name = name\n        self.log_path = log_path\n        self.func = func\n        self.args = args\n        self.html_mail_handler = html_mail_handler\n\n        if kwargs is None:\n            self.kwargs = {}\n        else:\n            self.kwargs = kwargs\n        if dependencies is None:\n            self.dependencies = []\n        else:\n            self.dependencies = dependencies\n\n        self._check_input_types()\n        if \" \" in self.name:\n            raise ValueError(f\"Task name cannot contain spaces. Got {self.name}\")\n\n        depedencies_names = []\n        for dependency in self.dependencies:\n            if dependency.task_name in depedencies_names:\n                raise ValueError(f\"Duplicate dependency name: {dependency.task_name}\")\n            depedencies_names.append(dependency.task_name)\n            if dependency.task_name == self.name:\n                raise ValueError(\n                    f\"Got dependency with same name as Task. \"\n                    f\"Task: {self.name}. Dependency: {dependency.task_name}\"\n                )\n\n        logger = logging.getLogger(self.name)\n        logger.setLevel(logging.DEBUG)\n        if logger.hasHandlers():\n            logger.handlers.clear()\n\n        file_handler = logging.FileHandler(self.log_path)\n        file_handler.setLevel(logging.INFO)\n        formatter = logging.Formatter(\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\")\n        file_handler.setFormatter(formatter)\n        logger.addHandler(file_handler)\n\n        if self.html_mail_handler is not None:\n            _html_mail_handler = self.html_mail_handler.copy()\n            _html_mail_handler.setFormatter(ExceptionHTMLFormatter())\n            _html_mail_handler.setLevel(logging.ERROR)\n            _html_mail_handler.subject = f\"Error in task {self.name}\"\n            logger.addHandler(_html_mail_handler)\n\n        self.logger = logger\n\n    def _check_input_types(self) -&gt; None:\n        \"\"\"\n        Validates all input parameter types.\n\n        Raises\n        ------\n        TypeError\n            If any parameter is not of the expected type.\n        \"\"\"\n        if not callable(self.func):\n            raise TypeError(f\"func must be callable. Got {type(self.func)}\")\n\n        if not isinstance(self.args, tuple):\n            raise TypeError(f\"args must be tuple. Got {type(self.args)}\")\n\n        if not isinstance(self.kwargs, dict):\n            raise TypeError(f\"kwargs must be dict. Got {type(self.kwargs)}\")\n\n        if self.html_mail_handler is not None and not isinstance(\n            self.html_mail_handler, HTMLSMTPHandler\n        ):\n            raise TypeError(\n                f\"mail_cfg must be of type HTMLSMTPHandler. Got {type(self.html_mail_handler)}\"\n            )\n\n        if not isinstance(self.dependencies, list):\n            raise TypeError(f\"dependencies must be list. Got {type(self.dependencies)}\")\n\n        for dependency in self.dependencies:\n            if not isinstance(dependency, TaskDependency):\n                raise TypeError(\n                    f\"dependency must be of type TaskDependency. Got {type(dependency)}\"\n                )\n\n    def get_dependencies_names(self) -&gt; set[str]:\n        \"\"\"\n        Get the names of all tasks this task depends on.\n\n        Returns\n        -------\n        set[str]\n            Set of dependency task names.\n        \"\"\"\n        return {dependency.task_name for dependency in self.dependencies}\n\n    def run(self, executing_process: Process | None = None) -&gt; TaskResult:\n        \"\"\"\n        Execute the task's function with its arguments and dependencies.\n\n        This method runs the task's function, automatically injecting results from\n        dependent tasks as specified in the dependency configuration. Logs the task\n        execution and captures any exceptions.\n\n        Parameters\n        ----------\n        executing_process : Process, optional\n            The parent Process executing this task. Used to retrieve results from\n            dependent tasks. Defaults to None.\n\n        Returns\n        -------\n        TaskResult\n            Object containing:\n            - worked (bool): True if execution succeeded, False otherwise.\n            - result: The return value of the function if successful, None if failed.\n            - exception (Exception | None): The exception raised if execution failed,\n            None if successful.\n        \"\"\"\n        final_args = list(self.args)  # Start with original positional args\n        final_kwargs = self.kwargs.copy()  # Start with original keyword args\n\n        if executing_process is not None:\n            for dep in self.dependencies:\n                dep_result = executing_process.runner.passed_results[dep.task_name].result\n                if dep.use_result_as_additional_args:\n                    final_args.append(dep_result)\n                if dep.use_result_as_additional_kwargs:\n                    final_kwargs[dep.additional_kwarg_name] = dep_result\n\n        try:\n            self.logger.info(f\"Starting {self.name}.\")\n            result = self.func(*final_args, **final_kwargs)\n            self.logger.info(f\"Finished {self.name}.\")\n            return TaskResult(True, result, None)\n        except Exception as e:\n            report = \"\"\n            if executing_process is not None:\n                dependencies_names = [\n                    d.name for d in executing_process.get_dependant_tasks(self.name)\n                ]\n                if dependencies_names:\n                    report = (\n                        \"&lt;h3&gt;Downstream Impact&lt;/h3&gt;&lt;p&gt;The following tasks will be skipped:&lt;/p&gt;&lt;ul&gt;\"\n                    )\n                    report += \"\".join(\n                        f\"&lt;li&gt;{dependency_name}&lt;/li&gt;\" for dependency_name in dependencies_names\n                    )\n                    report += \"&lt;/ul&gt;\"\n            report += f\"&lt;p&gt;&lt;b&gt;Context:&lt;/b&gt;&lt;br&gt;Function: {self.func.__name__}\"\n            report += f\"&lt;br&gt;Args: {self.args}&lt;br&gt;Kwargs: {self.kwargs}&lt;/p&gt;\"\n            self.logger.exception(e, extra={\"post_traceback_html_body\": report})\n            return TaskResult(False, None, e)\n</code></pre>"},{"location":"reference/#processes.task.Task.get_dependencies_names","title":"<code>get_dependencies_names()</code>","text":"<p>Get the names of all tasks this task depends on.</p>"},{"location":"reference/#processes.task.Task.get_dependencies_names--returns","title":"Returns","text":"<p>set[str]     Set of dependency task names.</p> Source code in <code>src/processes/task.py</code> <pre><code>def get_dependencies_names(self) -&gt; set[str]:\n    \"\"\"\n    Get the names of all tasks this task depends on.\n\n    Returns\n    -------\n    set[str]\n        Set of dependency task names.\n    \"\"\"\n    return {dependency.task_name for dependency in self.dependencies}\n</code></pre>"},{"location":"reference/#processes.task.Task.run","title":"<code>run(executing_process=None)</code>","text":"<p>Execute the task's function with its arguments and dependencies.</p> <p>This method runs the task's function, automatically injecting results from dependent tasks as specified in the dependency configuration. Logs the task execution and captures any exceptions.</p>"},{"location":"reference/#processes.task.Task.run--parameters","title":"Parameters","text":"<p>executing_process : Process, optional     The parent Process executing this task. Used to retrieve results from     dependent tasks. Defaults to None.</p>"},{"location":"reference/#processes.task.Task.run--returns","title":"Returns","text":"<p>TaskResult     Object containing:     - worked (bool): True if execution succeeded, False otherwise.     - result: The return value of the function if successful, None if failed.     - exception (Exception | None): The exception raised if execution failed,     None if successful.</p> Source code in <code>src/processes/task.py</code> <pre><code>def run(self, executing_process: Process | None = None) -&gt; TaskResult:\n    \"\"\"\n    Execute the task's function with its arguments and dependencies.\n\n    This method runs the task's function, automatically injecting results from\n    dependent tasks as specified in the dependency configuration. Logs the task\n    execution and captures any exceptions.\n\n    Parameters\n    ----------\n    executing_process : Process, optional\n        The parent Process executing this task. Used to retrieve results from\n        dependent tasks. Defaults to None.\n\n    Returns\n    -------\n    TaskResult\n        Object containing:\n        - worked (bool): True if execution succeeded, False otherwise.\n        - result: The return value of the function if successful, None if failed.\n        - exception (Exception | None): The exception raised if execution failed,\n        None if successful.\n    \"\"\"\n    final_args = list(self.args)  # Start with original positional args\n    final_kwargs = self.kwargs.copy()  # Start with original keyword args\n\n    if executing_process is not None:\n        for dep in self.dependencies:\n            dep_result = executing_process.runner.passed_results[dep.task_name].result\n            if dep.use_result_as_additional_args:\n                final_args.append(dep_result)\n            if dep.use_result_as_additional_kwargs:\n                final_kwargs[dep.additional_kwarg_name] = dep_result\n\n    try:\n        self.logger.info(f\"Starting {self.name}.\")\n        result = self.func(*final_args, **final_kwargs)\n        self.logger.info(f\"Finished {self.name}.\")\n        return TaskResult(True, result, None)\n    except Exception as e:\n        report = \"\"\n        if executing_process is not None:\n            dependencies_names = [\n                d.name for d in executing_process.get_dependant_tasks(self.name)\n            ]\n            if dependencies_names:\n                report = (\n                    \"&lt;h3&gt;Downstream Impact&lt;/h3&gt;&lt;p&gt;The following tasks will be skipped:&lt;/p&gt;&lt;ul&gt;\"\n                )\n                report += \"\".join(\n                    f\"&lt;li&gt;{dependency_name}&lt;/li&gt;\" for dependency_name in dependencies_names\n                )\n                report += \"&lt;/ul&gt;\"\n        report += f\"&lt;p&gt;&lt;b&gt;Context:&lt;/b&gt;&lt;br&gt;Function: {self.func.__name__}\"\n        report += f\"&lt;br&gt;Args: {self.args}&lt;br&gt;Kwargs: {self.kwargs}&lt;/p&gt;\"\n        self.logger.exception(e, extra={\"post_traceback_html_body\": report})\n        return TaskResult(False, None, e)\n</code></pre>"},{"location":"reference/#processes.task.TaskDependency--attributes","title":"Attributes","text":"<p>task_name : str     The name of the task this dependency refers to. use_result_as_additional_args : bool     If True, the result of the dependency task will be passed as an     additional positional argument as the last argument. Defaults to False. use_result_as_additional_kwargs : bool     If True, the result of the dependency task will be passed as a     keyword argument. Defaults to False. additional_kwarg_name : str | None     The name of the keyword argument to use if use_result_as_additional_kwargs     is True. Required when use_result_as_additional_kwargs is True.     Defaults to None.</p>"},{"location":"reference/#processes.task.TaskDependency--raises","title":"Raises","text":"<p>TypeError     If any parameter type is invalid or if use_result_as_additional_kwargs     is True but additional_kwarg_name is not a string.</p> Source code in <code>src/processes/task.py</code> <pre><code>class TaskDependency:\n    \"\"\"\n    Represents a dependency relationship between tasks.\n\n    Defines how a task depends on another task, including how the result\n    of the dependency should be passed to the dependent task (as additional\n    positional arguments, keyword arguments, or both).\n\n    Attributes\n    ----------\n    task_name : str\n        The name of the task this dependency refers to.\n    use_result_as_additional_args : bool\n        If True, the result of the dependency task will be passed as an\n        additional positional argument as the last argument. Defaults to False.\n    use_result_as_additional_kwargs : bool\n        If True, the result of the dependency task will be passed as a\n        keyword argument. Defaults to False.\n    additional_kwarg_name : str | None\n        The name of the keyword argument to use if use_result_as_additional_kwargs\n        is True. Required when use_result_as_additional_kwargs is True.\n        Defaults to None.\n\n    Raises\n    ------\n    TypeError\n        If any parameter type is invalid or if use_result_as_additional_kwargs\n        is True but additional_kwarg_name is not a string.\n    \"\"\"\n\n    def __init__(\n        self,\n        task_name: str,\n        use_result_as_additional_args: bool = False,\n        use_result_as_additional_kwargs: bool = False,\n        additional_kwarg_name: str = \"\",\n    ):\n        self.task_name = task_name\n        self.use_result_as_additional_args = use_result_as_additional_args\n        self.use_result_as_additional_kwargs = use_result_as_additional_kwargs\n        self.additional_kwarg_name = additional_kwarg_name\n\n        if not isinstance(self.task_name, str):\n            raise TypeError(f\"task_name must be of type str. Got {type(self.task_name)}\")\n        if not isinstance(self.use_result_as_additional_args, bool):\n            raise TypeError(\n                f\"use_result_as_additional_args must be of type bool. \"\n                f\"Got {type(self.use_result_as_additional_args)}\"\n            )\n        if not isinstance(self.use_result_as_additional_kwargs, bool):\n            raise TypeError(\n                f\"use_result_as_additional_kwargs must be of type bool. \"\n                f\"Got {type(self.use_result_as_additional_kwargs)}\"\n            )\n\n        if self.use_result_as_additional_kwargs and self.additional_kwarg_name == \"\":\n            raise TypeError(\n                \"If use_result_as_additional_kwargs is True, additional_kwarg_name\"\n                \" must be a non-empty string.\"\n            )\n\n    def __hash__(self) -&gt; int:\n        \"\"\"\n        Return hash of the dependency based on task name.\n\n        Returns\n        -------\n        int\n            Hash value based on the task_name attribute.\n        \"\"\"\n        return hash(self.task_name)\n</code></pre>"},{"location":"reference/#processes.task.TaskDependency.__hash__","title":"<code>__hash__()</code>","text":"<p>Return hash of the dependency based on task name.</p>"},{"location":"reference/#processes.task.TaskDependency.__hash__--returns","title":"Returns","text":"<p>int     Hash value based on the task_name attribute.</p> Source code in <code>src/processes/task.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"\n    Return hash of the dependency based on task name.\n\n    Returns\n    -------\n    int\n        Hash value based on the task_name attribute.\n    \"\"\"\n    return hash(self.task_name)\n</code></pre>"},{"location":"reference/#processes.html_logging.HTMLSMTPHandler--attributes","title":"Attributes","text":"<p>mailhost : tuple[str, int]     A tuple of (host, port) for the SMTP server. fromaddr : str     The email address to send messages from. toaddrs : list[str]     List of email addresses to send messages to. credentials : tuple[str, str] | None     A tuple of (username, password) for SMTP authentication. Defaults to None. secure : tuple | tuple[str, str] | tuple[str, str, ssl.SSLContext] | None     Security configuration for SMTP connection. Can be an empty tuple for no security,     a tuple of (certfile, keyfile), or (certfile, keyfile, SSLContext).     Defaults to None. timeout : int     Connection timeout in seconds. Defaults to 5.</p> Source code in <code>src/processes/html_logging.py</code> <pre><code>class HTMLSMTPHandler(logging.handlers.SMTPHandler):\n    \"\"\"\n    A logging handler that sends log records via SMTP as HTML formatted emails.\n\n    Extends the standard SMTPHandler to support HTML-formatted email messages,\n    enabling richer formatting and styling in error notifications.\n\n    Attributes\n    ----------\n    mailhost : tuple[str, int]\n        A tuple of (host, port) for the SMTP server.\n    fromaddr : str\n        The email address to send messages from.\n    toaddrs : list[str]\n        List of email addresses to send messages to.\n    credentials : tuple[str, str] | None\n        A tuple of (username, password) for SMTP authentication. Defaults to None.\n    secure : tuple | tuple[str, str] | tuple[str, str, ssl.SSLContext] | None\n        Security configuration for SMTP connection. Can be an empty tuple for no security,\n        a tuple of (certfile, keyfile), or (certfile, keyfile, SSLContext).\n        Defaults to None.\n    timeout : int\n        Connection timeout in seconds. Defaults to 5.\n    \"\"\"\n\n    def __init__(\n        self,\n        mailhost: tuple[str, int],\n        fromaddr: str,\n        toaddrs: list[str],\n        credentials: tuple[str, str] | None = None,\n        secure: tuple[()]\n        | tuple[str]\n        | tuple[str, str]\n        | tuple[str, str, ssl.SSLContext]\n        | None = None,\n        timeout: int = 5,\n    ):\n        self._crd = credentials\n        self._sec = secure\n        self._to = timeout\n\n        super().__init__(\n            mailhost,\n            fromaddr,\n            toaddrs,\n            \"\",\n            credentials=credentials,\n            secure=secure,  # type: ignore[arg-type]\n            timeout=timeout,\n        )\n\n    def copy(self) -&gt; \"HTMLSMTPHandler\":\n        \"\"\"Create a shallow copy of this handler.\n\n        Returns\n        -------\n        HTMLSMTPHandler\n            A new HTMLSMTPHandler instance with the same configuration.\n        \"\"\"\n        return HTMLSMTPHandler(\n            self.mailhost,  # type: ignore[arg-type]\n            self.fromaddr,\n            self.toaddrs,\n            credentials=self._crd,\n            secure=self._sec,\n            timeout=self._to,\n        )\n\n    def __copy__(self) -&gt; \"HTMLSMTPHandler\":\n        \"\"\"Support for copy.copy() method.\n\n        Returns\n        -------\n        HTMLSMTPHandler\n            A shallow copy of this handler.\n        \"\"\"\n        return self.copy()\n\n    def emit(self, record: logging.LogRecord) -&gt; None:\n        \"\"\"Send a log record via email as HTML formatted message.\n\n        Formats the log record using the handler's formatter and sends it\n        as an HTML-formatted email. Errors during sending are handled gracefully.\n\n        Parameters\n        ----------\n        record : logging.LogRecord\n            The log record to send.\n        \"\"\"\n        try:\n            port = self.mailport\n            if not port:\n                port = smtplib.SMTP_PORT\n            smtp = smtplib.SMTP(self.mailhost, port)\n            msg = self.format(record)\n\n            # Create MIMEText object with HTML content\n            mime_msg = MIMEText(msg, \"html\")\n            mime_msg[\"From\"] = self.fromaddr\n            mime_msg[\"To\"] = \",\".join(self.toaddrs)\n            mime_msg[\"Subject\"] = self.getSubject(record)\n            mime_msg[\"Date\"] = formatdate()\n\n            if self.username:\n                if self.secure is not None:\n                    smtp.starttls(*self.secure)\n                smtp.login(self.username, self.password)\n            smtp.sendmail(self.fromaddr, self.toaddrs, mime_msg.as_string())\n            smtp.quit()\n        except Exception:\n            self.handleError(record)\n</code></pre>"},{"location":"reference/#processes.html_logging.HTMLSMTPHandler.__copy__","title":"<code>__copy__()</code>","text":"<p>Support for copy.copy() method.</p>"},{"location":"reference/#processes.html_logging.HTMLSMTPHandler.__copy__--returns","title":"Returns","text":"<p>HTMLSMTPHandler     A shallow copy of this handler.</p> Source code in <code>src/processes/html_logging.py</code> <pre><code>def __copy__(self) -&gt; \"HTMLSMTPHandler\":\n    \"\"\"Support for copy.copy() method.\n\n    Returns\n    -------\n    HTMLSMTPHandler\n        A shallow copy of this handler.\n    \"\"\"\n    return self.copy()\n</code></pre>"},{"location":"reference/#processes.html_logging.HTMLSMTPHandler.copy","title":"<code>copy()</code>","text":"<p>Create a shallow copy of this handler.</p>"},{"location":"reference/#processes.html_logging.HTMLSMTPHandler.copy--returns","title":"Returns","text":"<p>HTMLSMTPHandler     A new HTMLSMTPHandler instance with the same configuration.</p> Source code in <code>src/processes/html_logging.py</code> <pre><code>def copy(self) -&gt; \"HTMLSMTPHandler\":\n    \"\"\"Create a shallow copy of this handler.\n\n    Returns\n    -------\n    HTMLSMTPHandler\n        A new HTMLSMTPHandler instance with the same configuration.\n    \"\"\"\n    return HTMLSMTPHandler(\n        self.mailhost,  # type: ignore[arg-type]\n        self.fromaddr,\n        self.toaddrs,\n        credentials=self._crd,\n        secure=self._sec,\n        timeout=self._to,\n    )\n</code></pre>"},{"location":"reference/#processes.html_logging.HTMLSMTPHandler.emit","title":"<code>emit(record)</code>","text":"<p>Send a log record via email as HTML formatted message.</p> <p>Formats the log record using the handler's formatter and sends it as an HTML-formatted email. Errors during sending are handled gracefully.</p>"},{"location":"reference/#processes.html_logging.HTMLSMTPHandler.emit--parameters","title":"Parameters","text":"<p>record : logging.LogRecord     The log record to send.</p> Source code in <code>src/processes/html_logging.py</code> <pre><code>def emit(self, record: logging.LogRecord) -&gt; None:\n    \"\"\"Send a log record via email as HTML formatted message.\n\n    Formats the log record using the handler's formatter and sends it\n    as an HTML-formatted email. Errors during sending are handled gracefully.\n\n    Parameters\n    ----------\n    record : logging.LogRecord\n        The log record to send.\n    \"\"\"\n    try:\n        port = self.mailport\n        if not port:\n            port = smtplib.SMTP_PORT\n        smtp = smtplib.SMTP(self.mailhost, port)\n        msg = self.format(record)\n\n        # Create MIMEText object with HTML content\n        mime_msg = MIMEText(msg, \"html\")\n        mime_msg[\"From\"] = self.fromaddr\n        mime_msg[\"To\"] = \",\".join(self.toaddrs)\n        mime_msg[\"Subject\"] = self.getSubject(record)\n        mime_msg[\"Date\"] = formatdate()\n\n        if self.username:\n            if self.secure is not None:\n                smtp.starttls(*self.secure)\n            smtp.login(self.username, self.password)\n        smtp.sendmail(self.fromaddr, self.toaddrs, mime_msg.as_string())\n        smtp.quit()\n    except Exception:\n        self.handleError(record)\n</code></pre>"},{"location":"examples/advanced/","title":"Example 2: Task Dependencies &amp; Result Passing","text":""},{"location":"examples/advanced/#overview","title":"\ud83d\udc41\ufe0f\u200d\ud83d\udde8\ufe0f Overview","text":"<p>This example demonstrates how to create task dependencies and automatically pass results from one task to another. This is where the real power of the library shines!</p> <p>Also, at the end we'll see how to add email notification.</p>"},{"location":"examples/advanced/#scenario","title":"\ud83d\udd01 Scenario","text":"<p>Imagine you're building a data pipeline with 6 tasks:</p> <pre><code>                        \u250c\u2500\u2192 [2] validate \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                        \u2502                        \u2502\n[1] fetch_data \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                        \u251c\u2500\u2192 [4] prepare \u2500\u2192 [5] save \u2500\u2192 [6] report\n                        \u2502                        \u2502                              \u2191\n                        \u2514\u2500\u2192 [3] calculate_stats \u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nTask Dependencies:\n  1. fetch_data           - No dependencies\n  2. validate             - Depends on: fetch_data (passes result as arg)\n  3. calculate_stats      - Depends on: fetch_data (passes result as arg), validate (no result pass)\n  4. prepare_storage      - Depends on: validate (passes result as arg), calculate_stats (passes result as arg)\n  5. save_data            - Depends on: prepare_storage (passes result as arg)\n  6. generate_report      - Depends on: save_data (passes result as arg), calculate_stats (passes result as kwarg)\n</code></pre> <p>Key observations: - fetch_data starts first with no dependencies - validate and calculate_stats can run in parallel (both depend only on fetch_data) - prepare_storage waits for both validate and calculate_stats to complete - save_data depends on prepare_storage - generate_report depends on both save_data AND calculate_stats results, passing them in different ways</p>"},{"location":"examples/advanced/#code-walkthrough","title":"\ud83d\udcbb Code Walkthrough","text":""},{"location":"examples/advanced/#understanding-taskdependency","title":"Understanding TaskDependency","text":"<p>See how Task objects receive a list with their dependencies. Each <code>TaskDependency</code> object points to another task and specifies how to pass its result.</p> <pre><code># Task 1: Fetch data (no dependencies)\nt_fetch = Task(\"fetch_data\", f\"{log_dir}/fetch.log\", fetch_user_data)\n\n# Task 2: Validate (depends on fetch)\nt_validate = Task(\n    \"validate\",\n    f\"{log_dir}/validate.log\",\n    validate_data,\n    dependencies=[\n        TaskDependency(\n            \"fetch_data\",\n            use_result_as_additional_args=True,  # Pass fetch result as positional arg\n        )\n    ],\n)\n\n# Task 3: Calculate stats (depends on fetch, but also checks validate completion)\nt_stats = Task(\n    \"calculate_stats\",\n    f\"{log_dir}/stats.log\",\n    calculate_statistics,\n    dependencies=[\n        TaskDependency(\n            \"fetch_data\",\n            use_result_as_additional_args=True,  # Pass fetch result as positional arg\n        )\n    ],\n)\n\n# Task 4: Prepare (depends on both validate and stats, passing both results)\nt_prepare = Task(\n    \"prepare_storage\",\n    f\"{log_dir}/prepare.log\",\n    prepare_for_storage,\n    dependencies=[\n        TaskDependency(\n            \"validate\",\n            use_result_as_additional_args=True,  # validate result \u2192 1st arg\n        ),\n        TaskDependency(\n            \"calculate_stats\",\n            use_result_as_additional_args=True,  # stats result \u2192 2nd arg\n        ),\n    ],\n)\n</code></pre>"},{"location":"examples/advanced/#using-keyword-arguments","title":"Using Keyword Arguments","text":"<p>Task results can also be passed as keyword arguments:</p> <pre><code>def generate_report(save_result: str, stats: dict | None = None) -&gt; str:\n    \"\"\"Generate final report with optional statistics.\"\"\"\n    if stats is None:\n        stats = {\"avg_age\": 0, \"avg_salary\": 0, \"total_records\": 0, \"age_range\": (0, 0), \"salary_range\": (0, 0)}\n    # Use both save_result and stats to generate report\n    ...\n\nt_report = Task(\n    \"generate_report\",\n    \"logs/report.log\",\n    generate_report,\n    dependencies=[\n        TaskDependency(\n            \"save_data\",\n            use_result_as_additional_args=True,  # save_data result \u2192 positional arg\n        ),\n        TaskDependency(\n            \"calculate_stats\",\n            use_result_as_additional_kwargs=True,\n            additional_kwarg_name=\"stats\"  # calculate_stats result \u2192 'stats' kwarg\n        ),\n    ]\n)\n</code></pre>"},{"location":"examples/advanced/#dependency-ordering-topological-sort","title":"Dependency Ordering (Topological Sort)","text":"<p>The Process automatically reorders tasks using Kahn's algorithm:</p> <pre><code># Order of creation (doesn't matter)\ntasks = [t4, t1, t3, t2]\n\n# Automatic reordering by Process\nwith Process(tasks) as process:\n    # Internal order becomes: t1 \u2192 (t2, t3 in parallel) \u2192 t4\n    process.run(parallel=True)\n</code></pre>"},{"location":"examples/advanced/#key-concepts","title":"\ud83d\udd11 Key Concepts","text":""},{"location":"examples/advanced/#positional-arguments-use_result_as_additional_argstrue","title":"Positional Arguments (<code>use_result_as_additional_args=True</code>)","text":"<p>Results are appended to the task function's positional arguments:</p> <pre><code>def func(a, b, c):  # Original signature\n    pass\n\n# With dependency passing a result\nt = Task(\n    \"task\",\n    \"log.log\",\n    func,\n    args=(1, 2),  # Original args\n    dependencies=[TaskDependency(\"source\", use_result_as_additional_args=True)]\n)\n\n# Effective call: func(1, 2, &lt;source_result&gt;)\n</code></pre>"},{"location":"examples/advanced/#keyword-arguments-use_result_as_additional_kwargstrue","title":"Keyword Arguments (<code>use_result_as_additional_kwargs=True</code>)","text":"<p>Results are passed with a specified keyword argument name:</p> <pre><code>def func(a, b=None):\n    pass\n\nt = Task(\n    \"task\",\n    \"log.log\",\n    func,\n    args=(1,),\n    kwargs={\"b\": \"default\"},\n    dependencies=[TaskDependency(\"source\", use_result_as_additional_kwargs=True, additional_kwarg_name=\"b\")]\n)\n\n# Effective call: func(1, b=&lt;source_result&gt;)\n# Note: keyword arg from dependency overrides kwargs\n</code></pre>"},{"location":"examples/advanced/#handling-multiple-dependencies","title":"Handling Multiple Dependencies","text":"<p>When a task depends on multiple tasks, results are added in dependency order:</p> <pre><code>dependencies=[\n    TaskDependency(\"task_a\", use_result_as_additional_args=True),  # 1st arg\n    TaskDependency(\"task_b\", use_result_as_additional_args=True),  # 2nd arg\n    TaskDependency(\"task_c\", use_result_as_additional_args=True)   # 3rd arg\n]\n\n# Effective call: func(res_a, res_b, res_c, ...)\n</code></pre>"},{"location":"examples/advanced/#email-notifications","title":"\ud83d\udce7 Email Notifications","text":"<p>If a task fails it can notify via email: - The name of the failing task - The python function being executed with its args and kwargs - The traceback of the error - The tasks that could not be executed in the process due to this failure.</p> <p>To set this up, you need to pass a <code>HTMLSMTPHandler</code> object to the Task constructor as </p> <pre><code>t = Task(\"task_name\", \"logfile\", func_to_run, html_mail_handler=smtp_handler) \n</code></pre> <p>To create an html_smtp_handler objects, you need to setup: - Who sends the email - A list with the recipients - SMTP credentials - Security tuple</p> <pre><code>smtp_handler = HTMLSMTPHandler(\n    ('smtp_server', 587), 'sender@example.com', ['admin@example.com', 'user@example.com'], \n    use_tls=True, credentials=('user', 'pass')\n)\n</code></pre>"},{"location":"examples/basic/","title":"Example 1: Simple Independent Tasks","text":""},{"location":"examples/basic/#overview","title":"Overview","text":"<p>This example demonstrates how to create and execute multiple independent (no dependencies) tasks. Use this when you have a set of unrelated operations that can potentially run in parallel.</p>"},{"location":"examples/basic/#what-youll-learn","title":"What You'll Learn","text":"<p>\u2705 Creating basic Task objects \u2705 Adding tasks to a Process \u2705 Running tasks sequentially vs in parallel \u2705 Accessing task results \u2705 Understanding execution timing  </p>"},{"location":"examples/basic/#scenario","title":"Scenario","text":"<p>Imagine you need to: 1. Fetch user count from a database 2. Fetch product count from a database 3. Fetch order count from a database</p> <p>All three operations are independent and can run in parallel.</p>"},{"location":"examples/basic/#code-walkthrough","title":"Code Walkthrough","text":""},{"location":"examples/basic/#step-1-define-your-task-functions","title":"Step 1: Define Your Task Functions","text":"<p>Each task needs a callable (function) that performs the work:</p> <pre><code>def fetch_user_count() -&gt; int:\n    \"\"\"Simulate fetching user count.\"\"\"\n    time.sleep(2)  # Simulate I/O operation\n    return 1000\n\ndef fetch_product_count() -&gt; int:\n    \"\"\"Simulate fetching product count.\"\"\"\n    time.sleep(2)  # Simulate I/O operation\n    return 5000\n\ndef fetch_order_count() -&gt; int:\n    \"\"\"Simulate fetching order count.\"\"\"\n    time.sleep(2)  # Simulate I/O operation\n    return 15000\n</code></pre>"},{"location":"examples/basic/#step-2-create-task-objects","title":"Step 2: Create Task Objects","text":"<p>Each task needs: - name: Unique identifier (no spaces allowed) - log_path: Where to write logs - func: The callable to execute - dependencies (optional): TaskDependency objects for dependent tasks</p> <pre><code>t1 = Task(\"fetch_users\", \"logs/fetch_users.log\", fetch_user_count)\nt2 = Task(\"fetch_products\", \"logs/fetch_products.log\", fetch_product_count)\nt3 = Task(\"fetch_orders\", \"logs/fetch_orders.log\", fetch_order_count)\nt4 = Task(\n    \"calculate_metrics\",\n    \"logs/calculate_metrics.log\",\n    calculate_metrics,\n    dependencies=[\n        TaskDependency(\"fetch_users\", use_result_as_additional_args=True),\n        TaskDependency(\"fetch_products\", use_result_as_additional_args=True),\n        TaskDependency(\"fetch_orders\", use_result_as_additional_args=True),\n    ]\n)\n</code></pre>"},{"location":"examples/basic/#step-3-create-process-and-execute","title":"Step 3: Create Process and Execute","text":"<p>Use a context manager for automatic cleanup:</p> <pre><code>with Process([t1, t2, t3, t4]) as process:\n    # Sequential execution: ~6 seconds total (2+2+2+1)\n    start = time.time()\n    _ = process.run(parallel=False)\n    duration_seq = time.time() - start\n\nwith Process([t1, t2, t3, t4]) as process:\n    # Parallel execution: ~2 seconds total (all run concurrently)\n    start = time.time()\n    _ = process.run(parallel=True, max_workers=4)\n    duration_par = time.time() - start\n</code></pre>"},{"location":"examples/basic/#key-concepts","title":"Key Concepts","text":""},{"location":"examples/basic/#process-context-manager","title":"Process Context Manager","text":"<pre><code>with Process([tasks]) as process:\n    result = process.run()\n# Automatically closes all loggers after execution\n</code></pre> <p>This ensures proper resource cleanup even if exceptions occur.</p>"},{"location":"examples/basic/#parallel-vs-sequential","title":"Parallel vs Sequential","text":"Aspect Sequential Parallel Execution Time Sum of all task times Max of task times Worker Threads 1 Configurable (default 4) Best For Simple, dependent tasks I/O-bound, independent tasks Resource Usage Low Medium-High"},{"location":"examples/basic/#execution-timing","title":"Execution Timing","text":"<p>For three 2-second tasks: - Sequential: ~6 seconds - Parallel (3 workers): ~2 seconds - Parallel (1 worker): ~6 seconds (falls back to sequential)</p>"},{"location":"examples/basic/#common-modifications","title":"Common Modifications","text":""},{"location":"examples/basic/#modify-task-arguments","title":"Modify Task Arguments","text":"<pre><code>def fetch_count(table_name: str) -&gt; int:\n    # Fetch from specific table\n    return database.count(table_name)\n\ntask = Task(\n    \"fetch_users\",\n    \"logs/fetch.log\",\n    fetch_count,\n    args=(\"users\",)  # Pass arguments\n)\n</code></pre>"},{"location":"examples/basic/#modify-task-keyword-arguments","title":"Modify Task Keyword Arguments","text":"<pre><code>def fetch_with_filter(table: str, status: str = \"active\") -&gt; int:\n    return database.count_where(table, status=status)\n\ntask = Task(\n    \"fetch_active\",\n    \"logs/fetch.log\",\n    fetch_with_filter,\n    args=(\"users\",),\n    kwargs={\"status\": \"active\"}\n)\n</code></pre>"},{"location":"examples/basic/#different-log-paths","title":"Different Log Paths","text":"<pre><code># Separate logs per task\nt1 = Task(\"task1\", \"logs/task1.log\", func1)\nt2 = Task(\"task2\", \"logs/task2.log\", func2)\n\n# Shared log file\nt1 = Task(\"task1\", \"logs/all.log\", func1)\nt2 = Task(\"task2\", \"logs/all.log\", func2)\n</code></pre>"},{"location":"examples/intro/","title":"Processes Examples &amp; Usage Guide","text":"<p>Welcome to the Processes library examples! This directory shows you how to build workflows where multiple operations run together, with some depending on others.</p>"},{"location":"examples/intro/#what-is-processes","title":"\ud83d\udcda What is Processes?","text":"<p>Processes is a Python library that helps you run multiple tasks in sequence or in parallel, automatically handling when one task needs data from another. It handles errors gracefully and sends email alerts when tasks fail \u2014 no extra code needed.</p>"},{"location":"examples/intro/#three-main-ideas","title":"Three Main Ideas","text":"<ul> <li>Task: A piece of work you want to do (run a function, fetch data, save results, etc.)</li> <li>TaskDependency: A task that depends on another task's result</li> <li>Process: The coordinator that runs all your tasks, handles data passing, and monitors for errors</li> </ul>"}]}